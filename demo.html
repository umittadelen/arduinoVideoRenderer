<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Miku Frame Animation</title>
	<style>
		body {
			margin: 0;
			background: #f0f0f0;
			overflow: hidden;
		}

		canvas {
			position: fixed;
			bottom: 0;
			right: 0;
			width: 200px;
			height: 200px;
			image-rendering: pixelated;
		}
	</style>
</head>

<body>
	<canvas id="mikuCanvas" width="112" height="105"
		style="position:fixed; bottom:0; right:0; width:200px; height:200px; image-rendering: pixelated;"></canvas>
	<script>
		const canvas = document.getElementById("mikuCanvas");
		const ctx = canvas.getContext("2d");
		const basePath = "./resources/miku/output/";

		// === Define animations as frame sequences ===
		const animations = {
			enter: { frames: ["enter_0.png", "enter_1.png", "enter_2.png", "enter_3.png", "enter_4.png", "enter_5.png", "enter_6.png", "enter_7.png"], duration: [40, 8, 8, 8, 8, 8, 8, 40] },
			blink: { frames: ["blink_0.png", "blink_1.png", "blink_2.png", "blink_3.png", "blink_4.png"], duration: [20, 8, 16, 8, 20] },
			idle: { frames: ["miku_idle.png"], duration: [0] },
			leave: { frames: ["leave_0.png", "leave_1.png", "leave_2.png", "leave_3.png", "leave_4.png", "leave_5.png", "leave_6.png"], duration: [8, 80, 8, 8, 8, 8, 8] },
			out: { frames: ["miku_out.png"], duration: [0] }
		};

		// Preload all frames
		const images = {};
		let totalFrames = 0;
		for (const key in animations) totalFrames += animations[key].frames.length;
		let loadedFrames = 0;

		for (const key in animations) {
			images[key] = [];
			animations[key].frames.forEach(src => {
				const img = new Image();
				img.src = basePath + src;
				img.onload = () => {
					loadedFrames++;
					if (loadedFrames === totalFrames) scheduleMiku();
				};
				images[key].push(img);
			});
		}

		// Draw a specific frame
		function drawFrame(animName, frameIndex) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(images[animName][frameIndex], 0, 0, canvas.width, canvas.height);
		}

		// Animate a sequence
		function playAnimation(animName, callback) {
			const anim = animations[animName];
			let i = 0;
			function nextFrame() {
				drawFrame(animName, i);
				i++;
				if (i < anim.frames.length) {
					setTimeout(nextFrame, anim.duration[i - 1] * 10);
				} else {
					if (callback) callback();
				}
			}
			nextFrame();
		}

		// === Random timings ===
		const minBlinkDelay = 2000, maxBlinkDelay = 6000;
		const reappearMinDelay = 2000, reappearMaxDelay = 11000;
		const idleContinueChance = 0.8, doubleBlinkChance = 0.25;
		const doubleBlinkMinGap = 200, doubleBlinkMaxGap = 600;

		// State functions
		function idleLoop() {
			const delay = Math.random() * (maxBlinkDelay - minBlinkDelay) + minBlinkDelay;
			setTimeout(() => {
				doBlink(() => {
					if (Math.random() < idleContinueChance) idleLoop();
					else leaveMiku();
				});
			}, delay);
		}

		function doBlink(callback) {
			playAnimation("blink", () => {
				if (Math.random() < doubleBlinkChance) {
					const gap = Math.random() * (doubleBlinkMaxGap - doubleBlinkMinGap) + doubleBlinkMinGap;
					setTimeout(() => {
						playAnimation("blink", callback);
					}, gap);
				} else callback();
			});
		}

		function showMiku() {
			playAnimation("enter", () => {
				drawFrame("idle", 0);
				idleLoop();
			});
		}

		function leaveMiku() {
			playAnimation("leave", () => {
				drawFrame("out", 0);
				scheduleMiku();
			});
		}

		function scheduleMiku() {
			const wait = Math.random() * (reappearMaxDelay - reappearMinDelay) + reappearMinDelay;
			setTimeout(showMiku, wait);
		}

		// Start with out frame
		drawFrame("out", 0);

		function resizeCanvas() {
			const scale = Math.min(window.innerWidth, window.innerHeight) * 0.2; // 20% of smaller side
			canvas.style.width = scale + "px";
			canvas.style.height = scale * (105 / 112) + "px"; // maintain frame ratio
		}
		window.addEventListener("resize", resizeCanvas);
		resizeCanvas();

	</script>
</body>
</html>